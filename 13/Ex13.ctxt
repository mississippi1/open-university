#BlueJ class context
comment0.target=Ex13
comment0.text=\n\ \n\n\ @Tomer\ Peker\n\ @1.2.0\n
comment1.params=
comment1.target=Ex13()
comment10.params=drmTemp\ newI\ newJ\ oldI\ oldJ\ stepsToGetHere
comment10.target=int\ tryGetPoint(int[][],\ int,\ int,\ int,\ int,\ int)
comment10.text=\n\ Recursivly\ try\ to\ go\ to\ point\ and\ checks\ if\ it's\ the\ villan's\ point.\ If\ so,\ return\ the\ steps,\ else\ return\ the\ number\ of\ points\ in\ all\ array\ plus\ one\ (to\ signal\ that\ the\ path\ is\ invalid)\n\ @param\ drmTemp\ an\ array\ of\ points\ \n\ @param\ newI\ the\ row\ of\ the\ new\ point\n\ @param\ newJ\ the\ column\ of\ the\ new\ point\n\ @param\ oldI\ the\ row\ of\ the\ old\ point\n\ @param\ oldJ\ the\ column\ of\ the\ old\ point\n\ @param\ stepsToGetHere\ the\ number\ of\ steps\ upto\ here\n\ @return\ the\ number\ of\ steps\ \n
comment2.params=n
comment2.target=int\ alternating(java.lang.String)
comment2.text=\n\ Method\ calculates\ the\ minimum\ switches\ between\ bits\ in\ string\ to\ make\ it\ alternating\n\ There\ are\ two\ possible\ options\ (010101...\ /\ 1010101....),\ so\ check\ how\ much\ operations\ \n\ are\ needed\ for\ each\ of\ them,\ and\ choose\ the\ loweest\n\ Time\ Complexity\ -\ We\ go\ over\ the\ string\ only\ once,\ so\ O(N)\n\ Space\ Complexity\ -\ We\ do\ not\ initialize\ any\ arrays\ in\ memory,\ so\ O(1)\n\ @param\ n\ string\ with\ only\ 0\ and\ 1\ and\ the\ same\ number\ of\ chars\n\ @returns\ the\ minimum\ transitions\n
comment3.params=a\ low\ high
comment3.target=int\ f(int[],\ int,\ int)
comment3.text=\n\ This\ methods\ sums\ the\ array,\ copied\ from\ the\ task\n\ @param\ a\ array\ to\ iterate\ over\n\ @param\ low\ the\ first\ index\ to\ include\ in\ sum\n\ @param\ high\ the\ end\ of\ indexes\ in\ sum\n\ @return\ the\ sum\ \n
comment4.params=a
comment4.target=int\ what(int[])
comment4.text=\n\ 1.The\ methods\ looks\ for\ the\ longest\ series\ of\ numbers\ in\ an\ array\ \n\ which\ their\ sum\ is\ even\ (returns\ 0\ for\ mod\ 2).\n\ 2.\ Time\ Complexity\ -\ Going\ over\ the\ array\ to\ caclucate\ the\ sum\ (O(n)),\ for\ every\ element\ (O(N)),\ for\ every\ element\ (O(n))\ ->\ O(N**3)\n\ Memory\ Complexity\ -\ The\ example\ did\ not\ initialize\ any\ new\ arrays,\ for\ O(1)\n\ 3.\n\ Time\ complexity\ -\ Going\ over\ a\ in\ the\ first\ loop\ (O(n))\ to\ calculate\ the\ sum\ o(n),\ \n\ \ if\ even\ than\ finished.\n\ \ If\ not,\ find\ the\ first\ odd\ number\ (because\ odd\ minus\ odd\ is\ even),\ \n\ \ \ \ \ \ which\ requires\ going\ over\ the\ array\ again\ (O(n)).\n\ \ So,\ at\ worst\ case\ O(2*n)\ \=\ O(n).\n\ Memory\ complexity\ -\ Array\ a\ is\ already\ in\ memory,\ so\ O(1).\n\ @param\ a\ array\ of\ natural\ numbers\n\ @return\ longest\ streak\ of\ numbers\ whose\ sum\ divides\ by\ 2\n
comment5.params=a
comment5.target=int\ idxOfFirstOddNumber(int[])
comment5.text=\n\ This\ method\ checks\ for\ the\ index\ of\ the\ first\ odd\ number\ \n\ @param\ a\ the\ arry\ to\ iterate\ over\n\ @return\ the\ place\ of\ the\ first\ odd\ number\n
comment6.params=a
comment6.target=boolean\ isWay(int[])
comment6.text=\n\ Methods\ finds\ if\ there\ is\ a\ way\ to\ traverse\ all\ points\ in\ the\ array\n\n\ @param\ \ a\ array\ to\ traverse\n\ @return\ \ \ \ if\ it\ can\ be\ traversed\n
comment7.params=a\ currentIdx\ steps\ lengthOfA
comment7.target=boolean\ isWayPrivate(int[],\ int,\ int,\ int)
comment7.text=\n\ Methods\ calculates\ recursivly\ if\ there\ is\ a\ way\ to\ traverse\ all\ points\ in\ the\ array\ \n\n\ @param\ \ a\ array\ to\ traverse\n\ @param\ \ currentIdx\ the\ current\ index\ of\ the\ curser\n\ @param\ \ steps\ the\ steps\ which\ the\ curser\ needs\ to\ take\n\ @param\ \ lengthOfA\ length\ of\ the\ array\ (passed\ because\ there\ is\ no\ need\ to\ calculate\ it\ again\ and\ again\ each\ iteration)\n\ @return\ \ \ \ if\ it\ can\ be\ traversed\n
comment8.params=drm\ i\ j
comment8.target=int\ prince(int[][],\ int,\ int)
comment8.text=\n\ The\ methods\ calulates\ the\ shortest\ path\ to\ the\ villan.\ \n\n\ @param\ \ drm\ array\ for\ all\ the\ rooftops\ and\ their\ respective\ heights\n\ @param\ \ i\ starting\ point\ X\ for\ the\ good\ guy\n\ @param\ \ j\ starting\ point\ Y\ for\ the\ good\ guy\n\ @return\ \ \ \ the\ number\ of\ tiles\ needed\ to\ be\ passed\ (including\ the\ first\ and\ last)\n
comment9.params=i\ j\ columnsLength\ rowsLength
comment9.target=boolean\ isPointValid(int,\ int,\ int,\ int)
comment9.text=\n\ Checks\ if\ a\ point\ can\ be\ accessed\n\ @param\ i\ the\ row\ of\ the\ point\n\ @param\ j\ the\ column\ of\ the\ point\n\ @param\ columnLength\ the\ number\ of\ columns\n\ @param\ rowsLength\ the\ number\ of\ rows\n\ @return\ is\ the\ point\ valid\n
numComments=11
